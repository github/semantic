foo :: a -> b -> c -> Int -> Maybe Int
factorial :: Num a => a -> a

g :: Ex -> Foo
g :: [Double] -> Int
g :: (Double, Int) -> Maybe Double
g :: b -> B a (D (E g ': h)) -> I [J k] (L m (O (N p ': q)))

g :: forall a. [a] -> [a]
g :: forall a b. (a, b) -> [a]
apply :: proxy d -> (forall g . d g => g a -> b) -> Union fs a -> b

g :: a ~ Int => a
g :: (a ~ Int) => a
sumCollects :: forall d1 d2. (B d1, B d2, E d1 ~ E d2) => d1 -> d2 -> d2

bar :: (Bar m) => Baz [Fiz Fuzz, Wiz, Wax, Woz] bar => a -> Waz m
foo :: (Baz '[Foo Wix a] biz, Waz woo) => Out a -> [Foo] -> Waz biz Baz

bar :: (f :< Bar) => Bar -> f
yield :: ((Yield b c) :< e) => b
